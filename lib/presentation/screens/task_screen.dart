// lib/features/tasks/task_list_screen.dart
import 'package:auto_route/auto_route.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_rating_bar/flutter_rating_bar.dart';
import 'package:intl/intl.dart';
import 'package:taskflow/core/providers.dart';
import 'package:taskflow/models/task.dart';

@RoutePage()
class TaskScreen extends ConsumerWidget {
  const TaskScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 1. Watch the taskListProvider to get the state of our tasks
    final asyncTasks = ref.watch(taskProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('My Tasks'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            // 2. Invalidate the provider to trigger a refresh
            onPressed: () => ref.invalidate(taskProvider),
          ),
        ],
      ),
      // 3. Use the `when` clause to handle loading/error/data states gracefully
      body: asyncTasks.when(
        data: (tasks) {
          if (tasks.isEmpty) {
            return const Center(
              child: Text('No tasks yet! Add one to get started.'),
            );
          }
          // Sort tasks to show completed ones at the bottom
          tasks.sort((a, b) => a.isCompleted ? 1 : -1);

          return ListView.builder(
            itemCount: tasks.length,
            itemBuilder: (context, index) {
              final task = tasks[index];
              return ListTile(
                title: Text(
                  task.title,
                  style: TextStyle(
                    decoration: task.isCompleted
                        ? TextDecoration.lineThrough
                        : null,
                    color: task.isCompleted ? Colors.grey : null,
                  ),
                ),
                subtitle: Text(
                  'Due: ${DateFormat.yMd().format(task.dueDate)} | Priority: ${task.priorityString}',
                ),
                leading: IconButton(
                  icon: Icon(
                    task.isCompleted
                        ? Icons.check_box
                        : Icons.check_box_outline_blank,
                    color: task.isCompleted ? Colors.green : Colors.amber,
                  ),
                  onPressed: () {
                    if (!task.isCompleted) {
                      _completeTaskDialog(context, ref, task);
                    }
                  },
                ),
                trailing: IconButton(
                  icon: Icon(Icons.delete_outline, color: Colors.red.shade300),
                  onPressed: () => _deleteTask(ref, task.id),
                ),
                onTap: () => _showTaskDetails(context, task),
              );
            },
          );
        },
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (err, stack) => Center(child: Text('Error: $err')),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => _addTask(ref),
        tooltip: 'Add Task',
        child: const Icon(Icons.add),
      ),
    );
  }

  // --- Action Methods ---
  // Note how they now accept WidgetRef to interact with providers

  Future<void> _addTask(WidgetRef ref) async {
    // In a real app, you would navigate to a new screen or show a form dialog.
    final newTask = Task(
      id: '', // ID is generated by the repository
      title: 'A New Task',
      dueDate: DateTime.now().add(const Duration(days: 1)),
      tags: ['example'],
    );
    // Use ref.read to call a method on the repository
    await ref.read(taskRepositoryProvider).insertTask(newTask);
    // Invalidate the list provider to refetch the data and update the UI
    ref.invalidate(taskProvider);
  }

  Future<void> _deleteTask(WidgetRef ref, String id) async {
    await ref.read(taskRepositoryProvider).deleteTask(id);
    ref.invalidate(taskProvider);
  }

  void _completeTaskDialog(BuildContext context, WidgetRef ref, Task task) {
    double rating = 3;
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Rate your satisfaction'),
        content: RatingBar.builder(
          initialRating: rating,
          minRating: 1,
          itemBuilder: (context, _) =>
              const Icon(Icons.star, color: Colors.amber),
          onRatingUpdate: (newRating) => rating = newRating,
        ),
        actions: [
          TextButton(
            child: const Text('Cancel'),
            onPressed: () => Navigator.of(context).pop(),
          ),
          TextButton(
            child: const Text('Complete Task'),
            onPressed: () async {
              task.isCompleted = true;
              task.satisfactionRating = rating.toInt();
              if (!context.mounted) return;
              await ref.read(taskRepositoryProvider).updateTask(task);
              ref.invalidate(taskProvider);
              if (!context.mounted) return;
              Navigator.of(context).pop();
            },
          ),
        ],
      ),
    );
  }

  void _showTaskDetails(BuildContext context, Task task) {
    // This method doesn't need to interact with providers, so it doesn't need ref.
    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(task.title),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                task.description.isEmpty ? 'No description' : task.description,
              ),
              const SizedBox(height: 16),
              Text('Due: ${DateFormat.yMd().add_jm().format(task.dueDate)}'),
              const SizedBox(height: 8),
              Text('Priority: ${task.priorityString}'),
              const SizedBox(height: 8),
              if (task.tags.isNotEmpty && task.tags.first.isNotEmpty)
                Wrap(
                  spacing: 6.0,
                  children: task.tags
                      .map((tag) => Chip(label: Text(tag)))
                      .toList(),
                ),
              if (task.isCompleted) ...[
                const SizedBox(height: 16),
                const Text('Completed with rating:'),
                RatingBarIndicator(
                  rating: task.satisfactionRating.toDouble(),
                  itemBuilder: (context, index) =>
                      const Icon(Icons.star, color: Colors.amber),
                  itemCount: 5,
                  itemSize: 25.0,
                ),
              ],
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('Close'),
            ),
          ],
        );
      },
    );
  }
}
