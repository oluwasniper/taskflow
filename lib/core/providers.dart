// lib/core/providers.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:taskflow/services/task_repository.dart'; // CORRECTED PATH!
import 'package:taskflow/models/task.dart'; // Make sure this path is correct

/// Provides an instance of TaskRepository.
final taskRepositoryProvider = Provider<TaskRepository>((ref) {
  return TaskRepository();
});

/// Manages the list of tasks using a StateNotifier.
final taskProvider =
    StateNotifierProvider<TaskListNotifier, AsyncValue<List<Task>>>((ref) {
      final repository = ref.watch(taskRepositoryProvider);
      return TaskListNotifier(repository);
    });

class TaskListNotifier extends StateNotifier<AsyncValue<List<Task>>> {
  final TaskRepository _taskRepository;

  TaskListNotifier(this._taskRepository) : super(const AsyncValue.loading()) {
    fetchTasks(); // Fetch initial tasks when the notifier is created
  }

  Future<void> fetchTasks() async {
    try {
      state = const AsyncValue.loading();
      final tasks = await _taskRepository.getTasks();
      state = AsyncValue.data(tasks);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }

  Future<void> addTask(Task task) async {
    try {
      // Optimistic update: Add the task to the local list first
      if (state is AsyncData<List<Task>>) {
        final currentTasks = state.value!;
        // Use copyWith to ensure immutability and add with a temporary ID if needed
        // For SQL, the ID is generated by the repository, so we'll re-fetch
        // to get the actual ID generated by the DB.
        state = AsyncValue.data([
          ...currentTasks,
          task.copyWith(id: 'temp_${DateTime.now().microsecondsSinceEpoch}'),
        ]);
      } else {
        state = const AsyncValue.loading();
      }

      await _taskRepository.insertTask(task);
      await fetchTasks(); // Re-fetch to get the actual ID and ensure consistency
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      await fetchTasks(); // Re-fetch to revert optimistic update on error
    }
  }

  Future<void> updateTask(Task task) async {
    try {
      if (state is AsyncData<List<Task>>) {
        final currentTasks = state.value!;
        final updatedList = currentTasks
            .map((t) => t.id == task.id ? task : t)
            .toList();
        state = AsyncValue.data(updatedList);
      } else {
        state = const AsyncValue.loading();
      }
      await _taskRepository.updateTask(task);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      await fetchTasks(); // Re-fetch to revert optimistic update on error
    }
  }

  Future<void> deleteTask(String taskId) async {
    try {
      if (state is AsyncData<List<Task>>) {
        final currentTasks = state.value!;
        final updatedList = currentTasks.where((t) => t.id != taskId).toList();
        state = AsyncValue.data(updatedList);
      } else {
        state = const AsyncValue.loading();
      }
      await _taskRepository.deleteTask(taskId);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
      await fetchTasks(); // Re-fetch to revert optimistic update on error
    }
  }
}
